"""
    Classes:
        BruteForceResult (dataclass).

    Fucntions:
        compute_cut_score.
        brute_force_maxcut.
        partition_draw.
"""

from dataclasses import dataclass
from typing import Set, List, Tuple, Dict, Optional

import networkx as nx
import numpy as np
from matplotlib.axes import Subplot

# Globals
BLUE = "#1f78b4"
RED = "#FFCCCB"

@dataclass
class BruteForceResult:
    """
    A container for data generated by the `brute_force_maxcut` function.

    Attributes:
        partitions_scores (List[Tuple[str, int]]): (partition, score) for all possible partitions.
        best_score (int): the best MaxCut score possible for the analyzed graph.
        optimal_partitions (Set[str]): all partitions that yield the best score.
    """

    partitions_scores: List[Tuple[str, int]]
    best_score: int
    optimal_partitions: Set[str]

def compute_cut_score(graph: nx.Graph, bitstring: str) -> int:
    """
    For a given graph and a given partition (defined by a bitstring), computes 
    the number of edges (= "cut score") that connect the two complimentary subsets
    of vertices that the bitstring defines (by the partition to ones and zeros).

    Args:
        graph (nx.Graph): the graph to compute the cut score for.
        bitstring (str): a bitstring that defines a certain partition of the graph
        into 2 complimentary subsets of vertices.

    Returns:
        (int): The cut score of `bitstring` w.r.t to `graph` = the number of edges that connect
        the 2 complimentary subsets of the graph's nodes.
    """

    # Reversing for little-endianess
    bitstring = bitstring[::-1]

    score = 0
    for edge in graph.edges:

        # Adds 1 if and only if the 2 nodes are of the same subset
        score += (int(bitstring[int(edge[0])]) ^ int(bitstring[int(edge[1])]))

    return score


def brute_force_maxcut(graph: nx.Graph, num_blue_nodes: Optional[int] = None) -> BruteForceResult:
    """
    Checks every possible partition of the graph's vertices by classical brute-force.

    Args:
        graph (nx.Graph): the graph so solve the MaxCut problem for.

    Returns:
        (BruteForceResult): A packed complete MaxCut anaylsis for the given graph.

    """

    # Associating each possible parittion with its cut-score
    scores_dict = {}
    num_nodes = graph.number_of_nodes()
    for num in range(2 ** num_nodes):
        bitstring = bin(num)[2:].zfill(num_nodes)

        if num_blue_nodes is not None and bitstring.count("1") != num_blue_nodes:
            continue

        scores_dict[bitstring] = compute_cut_score(graph, bitstring)

    partitions_scores = sorted(scores_dict.items(), key=lambda item: item[1], reverse=True)
    best_score = partitions_scores[0][1]

    optimal_partitions = set()
    for partition in partitions_scores:
        if partition[1] < best_score:
            break
        optimal_partitions.add(partition[0])

    return BruteForceResult(partitions_scores, best_score, optimal_partitions)


def partition_draw(graph: nx.Graph, bitstring: str, ax: Subplot, pos: Dict[int, np.ndarray]) -> None:
    """
    Draws an `nx.Graph` object partitioned into 2 colors.
    To be used from a Jupyter Notebook.

    Args:
        graph (nx.Graph): the grpah object to draw.
        bitstring (str): the partition to 2 colors (1 = blue group, 0 = red group).
        ax (Subplot): axis object to draw the graph into.
        pos (Dict[int, np.ndarray]): graph's layout.
    """

    little_endian_colors = [BLUE if d == "1" else RED for d in reversed(bitstring)]
    ordered_colors = [little_endian_colors[node_index] for node_index in graph.nodes]
    
    nx.draw(graph, with_labels=True, pos=pos, node_color=ordered_colors, ax=ax)


def get_random_partition(num_nodes: int, num_blue_nodes: Optional[int] = None) -> str:
    """
    Generate a random partition bitstring for a graph with `num_nodes` nodes.
    Optionally, specify the number of blue nodes (set to "1").
    If `num_blue_nodes` is None, defaults to half the nodes (rounded down).

    Args:
        num_nodes (int): Number of nodes in the graph.
        num_blue_nodes (Optional[int]): Number of nodes assigned to the blue group ("1").
            If None, defaults to num_nodes // 2.

    Returns:
        str: A bitstring of length `num_nodes` with exactly `num_blue_nodes` ones.
    """
    if num_blue_nodes is None:
        num_blue_nodes = num_nodes // 2

    indices = np.arange(num_nodes)
    blue_indices = np.random.choice(indices, size=num_blue_nodes, replace=False)
    bitstring = ["0"] * num_nodes
    for idx in blue_indices:
        bitstring[idx] = "1"
    return "".join(bitstring)


if __name__ == "__main__":
    for _ in range(10):
        print(get_random_partition(num_nodes=30, num_blue_nodes=7))